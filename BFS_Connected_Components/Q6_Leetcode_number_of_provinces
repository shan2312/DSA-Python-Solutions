def build_graph(isConnected):
    N = len(isConnected)
    adj_list = [[] for i in range(N)]
    
    for r in range(N):
        for c in range(N):
            if r != c and isConnected[r][c] == 1:
                adj_list[r].append(c)
                adj_list[c].append(r)
    return adj_list

def findCircleNum(isConnected):
    N = len(isConnected)
    adj_list = build_graph(isConnected)
    
    seen = set()
    
    def traverse_province(city):
        stack = [city]
        seen.add(city)
        
        while stack:
            present_city = stack.pop()
            for neighbor in adj_list[present_city]:
                if neighbor not in seen:
                    stack.append(neighbor)
                    seen.add(neighbor)
    
    count_provinces = 0
    for city in range(N):
        if city not in seen:
            traverse_province(city)
            count_provinces += 1
            
    return count_provinces
                    
               
#         par = [i for i in range(len(isConnected))]
#         rank = [1]*(len(isConnected))
        
#         def find(n):
#             p = par[n]
#             while(p!=par[p]):
#                 p = par[p]
#             return p
        
#         def union(n1, n2):
#             p1, p2 = find(n1), find(n2)
#             if(p1!=p2):
#                 if(rank[p1]<rank[p2]):
#                     par[p1] = p2
#                     rank[p2]+=rank[p1]
#                 else:
#                     par[p2] = p1
#                     rank[p1]+=rank[p2]
#             print(par)
#         for n1 in range(len(isConnected)):
#             for n2 in range(len(isConnected[0])):
#                 if(isConnected[n1][n2]==1 and n1!=n2):
#                     union(n1, n2)
            
    
#         v = set()
#         for n in range(len(isConnected)):
#             v.add(find(n))
        
#         return len(v)